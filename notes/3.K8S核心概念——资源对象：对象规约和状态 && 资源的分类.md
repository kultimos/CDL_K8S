# 资源和对象
  - k8s中的所有内容都被抽象为"资源",如Pod、Service、Node等都是资源;"对象"就是"资源"的实例,是持久化的实体;如某个具体的Pod、某个具体的Node;
  k8s使用这些实体去表示整个集群的状态
  - k8s的资源类别有很多种,kubectl可以通过配置文件来创建这些"对象",配置文件更像是描述对象"属性"的文件,配置文件格式可以是"JSON"或"YAML",常用
  "YAML";

  ## 对象的规约和状态
  
  ### 规约
  - "spec"是"规约","规格"的意思,spec是必需的,它描述了对象的期望状态————希望对象所具有的特征;当创建Kubernetes对象时,必须提供对象的规约,用来
  描述该对象的期望状态,以及关于对象的一些基本信息(例如名称);

  ### 状态
  - 表示对象的实际状态,该属性由k8s自己维护,k8s会通过一系列的控制器对对应的对象进行管理,让对象的实际状态尽可能的符合期望状态;

  ## 资源的分类
  - 作用域比较: 元数据 > 集群 > 命名空间
  ### 元数据级别资源
  - 对于资源的元数据的描述,每一个资源都可以使用元数据的数据

1.  #### Horizontal Pod Autoscaler (HPA)
    - Pod自动扩缩容: 可以根据CPU使用率或自定义指标(metric),自动对Pod进行扩容/缩容
    - 控制管理器默认每隔30s会查询metric的资源使用情况来进行Pod的自动扩缩容
    - 比较典型的应用场景: 我们可以根据配置自定义指标的方式,去java程序中获取目前的访问量、并发量,一旦这个值高于阈值就进行扩容,相反,等高峰期结束,
    又可以自动缩容,这样就避免了人为的扩缩容,还增强了系统的可用性;

2.  #### PodTemplate
    - PodTemplate是关于Pod的定义,但是被包含在其他的Kubernetes对象中(如Deployment、StatefulSet、DaemonSet等控制器);控制器通过Template
    信息来创建Pod
    
3.  #### LimitRange(需要资源的上下限)
    - 可以对集群内的Request(最少需要多少资源)和Limits(最多需要多少资源)的配置做一个全局的统一的限制,相当于批量设置了某一个范围内(某个命名空间)
    的Pod的资源使用限制
  
  ### 集群级别资源
  - 作用于集群之上,集群下的所有资源都可以共享使用

1.   #### Namespace
     - 命名空间资源
     
2.   #### Node
     - 节点资源: 不像其他的资源(如Pod和Namespace),Node本质上不是Kubernetes来创建的,Kubernetes只是管理Node上的资源;虽然可以通过Manifest
     创建一个Node对象,但Kubernetes也只是去检查是否真的是有这么一个Node,如果检查失败,也不会往上调度Pod;
     - 因为节点资源其实本质上使我们的服务器,k8s可以创建N个虚拟的Node节点,但如果并没有真实的服务器资源,也就无法调度Pod;

3.   #### ClusterRole
     - ClusterRole是一种角色定义,它定义了一组权限,这些权限可以被分配给用户、服务账户或其他主体
     - ClusterRole是集群范围的,意味着它定义的权限适用于整个集群中的所有命名空间

4.   #### ClusterRoleBinding
     - ClusterRoleBinding是将ClusterRole绑定到具体的主体(用户、组或服务账户)的资源,它将ClusterRole的权限应用于集群中的主体

  ### 命名空间级别资源
  - 作用于命名空间之上,只能在该命名空间范围内使用
  - 详解见: [](/notes/4.K8S核心概念——资源对象：命名空间级别资源之工作负载型%20Pod%20※.md)
    

